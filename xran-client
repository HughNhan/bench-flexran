#!/bin/bash

#######################################################################################
# Crucible Flexran client RUN function.
#   This module orchestrates L1 and Testmac processes.
#   It waits for Testmac to finish testing and then shuts down the processes.
#
#   'test-file' mode: Testmac exec's a list of tests specified in a test config file
#                     i.e test_file=/opt/flexran/tests/nr5g/fd/testmac_fd_mu0_5mhz.cfg.
#
#   'user-cmd' mode:  Testmac exec's a user-provided command likely for a single test.
#                     i.e "run 2 1 100 1001"
#######################################################################################
function init_mount_fs {
    # Flexran S/W is ~100GB. In development, we host mount it. Now, link it to the desired filepaths.
    ln -s /tmp/opt/flexran /opt/flexran
    ln -s /tmp/opt/intel /opt/intel
    ln -s /tmp/opt/dpdk-20.11 /opt/dpdk-20.11
}

function set_fec_mode {
    if [ "$fec_mode" == "hw" ]; then
        if [ -z "$PCIDEVICE_INTEL_COM_INTEL_FEC_5G" ]; then
            exit_error "PCIDEVICE_INTEL_COM_INTEL_FEC_5G is not defined. This must be defined to run flexran HW FEC"
        fi
        sed -i "s#<dpdkBasebandDevice>.*</dpdkBasebandDevice>#<dpdkBasebandDevice>${PCIDEVICE_INTEL_COM_INTEL_FEC_5G}</dpdkBasebandDevice>#" $1
        sed -i 's#<dpdkBasebandFecMode>.*</dpdkBasebandFecMode>#<dpdkBasebandFecMode>1</dpdkBasebandFecMode>#' $L1_CFG_FILE
    else
        sed -i 's#<dpdkBasebandFecMode>.*</dpdkBasebandFecMode>#<dpdkBasebandFecMode>0</dpdkBasebandFecMode>#' $1
    fi
}



FLEXROOT=/opt/flexran/bin/nr5g/gnb
declare -A timer_cfg
        timer_cfg[l1]=$FLEXROOT/l1/phycfg_timer.xml
        timer_cfg[testmac]=$FLEXROOT/testmac/testmac_cfg.xml
        timer_cfg[orucfg]=None

declare -A xran_cfg
        xran_cfg[l1]=$FLEXROOT/l1/orancfg/sub3_mu0_20mhz_4x4/gnb/phycfg_xran.xml
        xran_cfg[testmac]=$FLEXROOT/testmac/testmac_cfg.xml
        xran_cfg[orucfg]=$FLEXROOT/l1/orancfg/sub3_mu0_20mhz_4x4/gnb/xrancfg_sub6_oru.xml

PCIDEVICE_OPENSHIFT_IO_INTELNICS0=0000:4b:02.0,0000:4b:02.1

function start_l1_mode {
    xran=$1
    echo -e "\nCRU: Start L1 xran=$xran"
    source /opt/flexran_env_vars.sh

    # Launch L1 process in background. 
    # To get around L1 process exits as soon as its stdin is closed as a result of 
    # runnning in background, redirect its stdin to a pipe. 
    if [ -p  $L1_PIPE ]; then
       rm $L1_PIPE
    fi
    mkfifo $L1_PIPE
    /usr/bin/driver.sh vfio
    cd $(dirname $l1_cfg)
    tail -f $L1_PIPE | ./l1.sh -oru &
    sleep 20    # 10sec is recommended by Intel, but we are generous.
}

function start_testmac_mode {
    echo -e "\nCRU: Start TESTMAC xran=$1"
    source /opt/flexran_env_vars.sh

    # Launch Testmac process in background. Redirect stdin to a pipe.  See L1 note.
    if [ -p  $L2_PIPE ]; then
       rm $L2_PIPE
    fi
    mkfifo $L2_PIPE
    cd $(dirname $testmac_cfg)
    tail -f $L2_PIPE| ./l2.sh --testfile=$final_test_file &

    if [ "$test_file" == "none" ]; then
        sleep 5
        user_cmd="${usr1} ${usr2} ${usr3} ${usr4} ${usr5}"
        echo "$user_cmd" > $L2_PIPE
        echo -e "\nCRU: testmac user_cmd: " $user_cmd
    fi
}

# Function: fixup_cfg_files
#  Timer mode: fix up below
#    phycfg_timer: /opt/flexran/bin/nr5g/gnb/l1/
#    testmac_cfg: /opt/flexran/bin/nr5g/gnb/testmac/
#
#  XRAN Mode: fix up belows
#    phycfg_xran:      /opt/flexran/bin/nr5g/gnb/l1/orancfg/sub3_mu0_10mhz_4x4/gnb/
#    xrancfg_sub6_oru: /opt/flexran/bin/nr5g/gnb/l1/orancfg/sub3_mu0_10mhz_4x4/gnb/
#    testmac_cfg: /opt/flexran/bin/nr5g/gnb/testmac/
#
#    copy /opt/flexran/bin/nr5g/gnb/l1/orancfg/sub3_mu0_20mhz_4x4/gnb/testmac_clxsp_mu0_20mhz_hton_oru.cfg
#         to /opt/flexran/bin/nr5g/gnb/testmac,
#    and update this file:
#        phystart: 4 0 100007
#        setcore
#

oru_cfg=None
l1_cfg=None
testmac_cfg=None
oru_cfg=None
test_file=None

# Init config file vars depending on xran or not.
#   While at it, restore files to original state (previous run has modified them)
#
function init_cfgfile_vars {
    if [ $xran = true ]; then
        l1_cfg=${xran_cfg[l1]}
        testmac_cfg=${xran_cfg[testmac]}
        oru_cfg=${xran_cfg[orucfg]}

    else
        l1_cfg=${timer_cfg[l1]}
        testmac_cfg=${timer_cfg[testmac]}
    fi
}

function fixup_xran_cfg_files {
    echo $l1_cfg
    echo $testmac_cfg
    echo $oru_cfg
    # https://stackoverflow.com/questions/47886113/how-to-call-a-python-script-from-bash-with-arguments
     
    echo "options=" $options

    args=( 
        --l1_cfgfile "${l1_cfg}"
        --testmac_cfgfile "${testmac_cfg}"
    )
    if [ $xran = true ]; then
        echo "xran ON"
        args+=(
            --oru_cfgfile "${oru_cfg}"
            --oru_vfs_pci "${PCIDEVICE_OPENSHIFT_IO_INTELNICS0}"
            --testfile "${test_file}"
            --phystart 
        )
    fi
    if [ ! -z $options ]; then
        IFS=' ' read -r -a array <<< "$options"
        echo "array=" ${array[@]}
        args+=(${array[@]})
        echo "arg=" ${args[@]}
    fi

    # fix them
    /usr/bin/xautotest.py "${args[@]}"
    
    # Put copies of config files in crucible run dirs
    echo "cp $l1_cfg"
    cp $l1_cfg .

    echo "cp $testmac_cfg"
    cp $testmac_cfg .

   echo "cp ${l1_cfg}.orig"
    cp "${l1_cfg}".orig .

    echo "cp ${testmac}.orig"
    cp "${testmac}".orig .
    if [ $xran = true ]; then
        echo "cp $oru_cfg"
        cp $oru_cfg .
        echo  "${oru_cfg}.orig "
        cp "${oru_cfg}".orig .
    fi
    if [ $test_file != None ]; then
        echo "cp $test_file"
        cp $test_file .
        echo "cp ${test_file}.orig"
        cp "${test_file}".orig .
    fi

    # move file to the right destination for xran case
    if [ $xran = true ]; then
        cp $test_file $FLEXROOT/testmac/
        cp $test_file .
    fi
}

function restore_cfg_files {
    # If config files were used in the last run, restore them
    if [ -f "${l1_cfg}".orig ]; then
        echo "restore $l1_cfg $testmac_cfg"
        cp "${l1_cfg}".orig  $l1_cfg
        cp "${testmac_cfg}".orig  $testmac_cfg
    else
        echo "save $l1_cfg, $testmac_cfg"
        cp $l1_cfg "${l1_cfg}".orig
        cp $testmac_cfg "${testmac_cfg}".orig
    fi

    if [ $oru_cfg != None ]; then
        if [ -f  "${oru_cfg}".orig  ];then
            echo "restore $oru_cfg"
            cp "${oru_cfg}".orig  $oru_cfg
        else 
            echo "save $oru_cfg"
            cp $oru_cfg  "${oru_cfg}".orig
        fi
    fi

    if [ -f "${test_file}".orig ]; then
        echo "restore $oru_cfg"
        cp "${test_file}".orig  $test_file
    else
        echo "save $oru_cfg"
        cp $test_file "${test_file}".orig
    fi
}

function xran_main {

longopts="xran:,fec-mode:,test-file:,log-test:,usr1:,usr2:,usr3:,usr4:,usr5:"
opts=$(getopt -q -o "" --longoptions "$longopts" -n "getopt.sh" -- "$@");
if [ $? -ne 0 ]; then
    exit_error "Unrecognized option specified"
fi
eval set -- "$opts";
echo -e "\nCRU: opts= " $opts
while true; do
    case "$1" in
        --fec-mode)
            shift;
            fec_mode=$1
            if [ "$fec_mode" != "hw" ] && [ "$fec_mode" != "sw" ]; then
                echo "Invalid fec-mode:$1"
                fec_mode="hw"
            fi
            shift;
            ;;
        --usr1)
            # Ex:  --usr1='run' --usr2='2' --usr3='0' --usr4='5' --usr5='12001'
            shift;
            usr1=$1
            shift;
            ;;
        --usr2)
            shift;
            usr2=$1
            shift;
            ;;
        --usr3)
            shift;
            usr3=$1
            shift;
            ;;
        --usr4)
            shift;
            usr4=$1
            shift;
            ;;
        --usr5)
            shift;
            usr5=$1
            shift;
            ;;
        --test-file)
            # Example: test_file=/opt/flexran/tests/nr5g/fd/testmac_fd_mu0_5mhz.cfg
            shift;
            test_file=$1
            echo "test-file=$test_file"
            shift;
            ;;
        --log-test)
            # applicable to post processing only
            shift;
            shift;
            ;;
        --xran)
            shift;
            xran=true
            shift;
            ;;
        --)
            shift;
            break
            ;;
        *)
            exit_error "Unsupport option $1"
            break
            ;;
    esac
done
echo "\nCRU:Use fec-mode=$fec_mode"
init_mount_fs
init_cfgfile_vars
restore_cfg_files
set_fec_mode $l1_cfg
fixup_xran_cfg_files
#install_flexran_pic
date +%s.%N >begin.txt

echo "HN invoke l1 and testmac by hand"
sleep infinity

start_l1_mode $xran
start_testmac_mode $xran
# Poll for the result file to appear, 120sec max. 
total_wait=0
while [ $total_wait -le $FIRST_RESULT_WAIT_SEC ]
do
  if [ ! -f $FLEXRAN_RESULT_FILE ]; then
     total_wait=$((total_wait+10))
     sleep 10
     echo -e "\nCRU: Waited for results $total_wait seconds"
  else
     break
  fi
done
# Poll for completion 
error_status="None"
if [ $total_wait -ge $FIRST_RESULT_WAIT_SEC ]; then
    echo -e "\nCRU: Timeout waiting for results"
    error_status="Timeout"
else
    echo -e "\nCRU: Waiting for results to drain"
    # Kick Testmac to flush its stdout until the completion verbiage comes out
    flush_testmac &
    ( tail -f -n0 $FLEXRAN_LOG_FILE & ) | grep -q "$COMPLETION_SIGNATURE"
fi
echo  -e "\nCRU: Finish, error:$error_status. Stop TESTMAC and L1"
stop_testmac
stop_l1
date +%s.%N >end.txt
remove_flexran_pic
# Kill the subproceses e.g flush_testmac and anything else
kill $(jobs -p)
# That's all folks

}
